#include <iostream>
using namespace std;

// 插入排序
void InsertSort(int R[], int n) { // 待排关键字存储在R[]中，默认为整型，个数为n
  int i, j;
  int temp;
  for (i = 1; i < n; i++) {
    temp = R[i];
    j = i - 1;
    // 下面循环完成了从待排关键字之前的关键字开始扫描，如果大于待排关键字，则后移一位
    while (j >= 0 && R[j] > temp) {
      R[j + 1] = R[j];
      j--;
    }
    R[j + 1] = temp; // 找到插入位置，插入待排关键字
  }
}
// 时间复杂度分析：最好情况下，待排关键字已经有序，只需比较n-1次，无需移动，时间复杂度为O(n)
// 最坏情况下，待排关键字逆序，比较次数为1+2+...+n-1=(n-1)*n/2，移动次数为3+4+...+n+1=(n+3)(n-1)/2
// 时间复杂度为O(n^2)
// 空间复杂度为O(1)
// 对于直接插入排序，一趟排序并不能确保最终位置，因此需要多趟排序，直到所有关键字有序为止。这是插入类排序的一个特点。

// 折半插入排序
// 折半插入排序的基本思想和直接插入排序类似，区别是查找插入位置的方法不同，折半插入排序是采用折半查找法来查找插入位置的。
void BInsertSort(int R[], int n) {
  int i, j, low, high, mid;
  int temp;
  for (i = 1; i < n; i++) {
    temp = R[i];
    low = 0;
    high = i - 1;
    while (low <= high) {     // 当low>high时，退出循环
      mid = (low + high) / 2; // 计算新的中间位置
      if (R[mid] > temp) // 如果中间的数大于待排关键字，则在前半区继续查找
        high = mid - 1;
      else // 如果中间的数小于等于待排关键字，则在后半区继续查找
        low = mid + 1;
    }
    for (j = i - 1; j >= high + 1; j--) // 将high+1到i-1的关键字后移一位
      R[j + 1] = R[j];
    R[high + 1] = temp; // 将待排关键字插入到正确位置
  }
}
// 时间复杂度分析：时间复杂度的最好情况为O(nlog2n)，最坏情况为O(n^2)，平均情况为O(n^2)
// 空间复杂度同直接插入排序一样，为O(1)

// 希尔排序
// 希尔排序又叫缩小增量排序，其本质还是插入排序，只不过是将待排关键字序列分成若干个子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。
// 这个规则的体现就是增量的选取，增量的选取是希尔排序的核心，增量的选取可以有很多种，这里采用的是Hibbard增量序列，即增量序列为1,3,7,15,...,2^k-1,...,1
// 增量是递减的，最后一个增量值必须为1，因为最后一趟排序必须是直接插入排序，而直接插入排序的增量值为1。

void ShellSort(int R[], int n) {
  int i, j, k;
  int temp;
  int increment = n; // 增量序列的初值
  do {
    increment = increment / 3 + 1; // 增量序列的递推式
    for (i = increment; i < n; i++) {
      if (R[i] < R[i - increment]) { // 需将R[i]插入有序增量子表
        temp = R[i];
        for (j = i - increment; j >= 0 && temp < R[j]; j -= increment)
          R[j + increment] = R[j]; // 记录后移，查找插入位置
        R[j + increment] = temp;   // 插入
      }
    }
  } while (increment > 1);
}
// 希尔排序的时间复杂度和增量序列的选取有关，目前还没有找到最好的增量序列，但是已经证明，希尔排序的时间复杂度为O(n^1.5)
// 希尔排序的空间复杂度为O(1)

// 起泡排序
// 起泡排序又称冒泡排序。它是通过一系列的交换动作完成的。收i按第一个关键字和第二个关键字比较，
// 如果第二个大，则二者交换位置，否则不交换；二年后第二个关键字和第三个关键字比较，以此类推，直到第n-1个关键字和第n个关键字比较为止。
// 这样一趟下来，最大的关键字就排在了最后。然后再从头开始进行第二趟排序，直到所有关键字都排好序为止。
void BubbleSort(int R[], int n) { // 默认待排序关键字为整型
  int i, j, flag;
  int temp;
  for (i = n - 1; i >= 1; i--) {
    flag = 0; // flag用来标记一趟排序过程中是否发生了关键字交换
    for (j = 1; j <= i; j++)
      if (R[j - 1] > R[j]) {
        temp = R[j];
        R[j] = R[j - 1];
        R[j - 1] = temp;
        flag = 1; // 交换flag的值为1
      }
    if (flag == 0) // 一趟排序过程中没有发生关键字交换，则证明序列有序，排序结束
      return;
  }
}
// 时间复杂度分析，由起泡排序算法可知，可选取最内存循环中的关键字交换操作为基本操作，因此，起泡排序的时间复杂度为O(n^2)
// 最坏情况，待排序序列逆序，此时需要进行n-1趟排序，每趟排序需要进行n-i次关键字交换，因此，最坏情况下的时间复杂度为O(n^2)
// 最好情况，待排序列有序，此时只需要进行一趟排序，且不需要进行关键字交换，因此，最好情况下的时间复杂度为O(n)
// 空间复杂度分析，由算法代码可以看出，起泡排序的空间复杂度为O(1)

// 快速排序
// 快速排序也是交换类的排序，它通过多次划分操作来实现排序。以升序为例，其执行流程可以概括为：每一趟选择当前所有子序列中的
// 一个关键字（通常是第一个）作为枢轴，将所有小于枢轴的关键字移到枢轴的左边，将所有大于枢轴的关键字移到枢轴的右边，然后对左右两个子序列分别进行快速排序。
// 快速排序的关键在于划分操作，划分操作的实现有很多种，这里采用的是Hoare划分方法，即将枢轴关键字放在序列的第一个位置，然后从序列的两端交替向中间扫描，直到两个指针相遇为止。
void QuickSort(int R[], int low, int high) {
  // 对R[low..high]进行快速排序
  int temp;
  int i = low, j = high;
  if (low < high) {
    temp = R[low]; // 用子表的第一个记录作为枢轴
    while (i < j) {
      while (i < j &&
             R[j] >= temp) // 从右向左扫描，找第一个关键字小于temp的记录R[j]
        j--;
      while (i < j &&
             R[i] < temp) // 从左向右扫描，找第一个关键字大于temp的记录R[i]
        i++;
      if (i < j) {
        R[j] = R[i];
        --j;
      }
    }
    R[i] = temp;               // 将temp放在最终位置
    QuickSort(R, low, i - 1);  // 对低子表进行递归排序
    QuickSort(R, i + 1, high); // 对高子表进行递归排序
  }
}
// 时间复杂度分析：
// 快速排序最好情况下的时间复杂度为O(nlogn)，待排序列越接近无序，本算法的效率越高。
// 最坏情况下的时间复杂度是O(n^2)，当待排序列为正序或逆序时，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。
// 平均情况下的时间复杂度为O(nlogn)。快速排序的排序趟数和初始序列有关。
// 本算法的空间复杂度为O(logn)，递归调用的栈深度为O(logn)。

// 简单选择排序
// 选择类排序的主要动作是选择，简单选择排序采用最简单的选择方法，从头至尾顺序扫描序列，找出最小的一个关键字，
// 和第一个关键字交换，接着从剩下的关键字中继续这种选择和交换，最后使序列有序。
void SelectSort(int R[], int n) {
  int i, j, k;
  int temp;
  for (i = 0; i < n; i++) {
    k = i;
    // 从无序序列中找出最小的关键字
    for (j = i + 1; j < n; j++)
      if (R[j] < R[k])
        k = j;
    // 将最小的关键字与无序序列的第一个关键字交换
    temp = R[i];
    R[i] = R[k];
    R[k] = temp;
  }
}
// 时间复杂度分析：
// 通过本算法代码可以看出，两层循环的执行次数和初始序列没有关系，外层循环执行n次，
// 内层循环执行n-1次，将最内层循环中的比较操作视为关键操作，起执行次数为（n-1）+(n-2)+...+2+1=n(n-1)/2，
// 即时间复杂度为O(n^2)。
// 空间复杂度分析：
// 算法所需的辅助存储空间不随待排序序列的规模而变化，因此，空间复杂度为O(1)。

// 堆排序
// 堆是一种数据结构，可以把对看成一颗完全二叉树，这颗完全二叉树满足：任何一个非叶节点的值都不大于（或不小于）其左右孩子节点的值。
// 若父亲大孩子小，则这样的堆叫做大顶堆；若父亲小孩子大，则这样的堆叫做小顶堆。
// 堆排序是一种树形选择排序，它的特点是：在排序的过程中，将R[1..n]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，
// 根据堆的定义知道，代表堆的这颗完全二叉树的根节点的关键字是所有关键字中最小（或最大）的，因此，根节点的关键字是当前堆中所有关键字的最小（或最大）值。
// 因此将一个无序序列调整成一个堆，就可以找出这个序列中的最小（或最大）值，然后将找出的这个值交换到序列的最后（或最前），这样，有序序列关键字增加1个，无序序列
// 中关键字减少一个，对新的无序序列重复这样的操作，就实现了排序。这就是堆排序的思想。

// 本函数完成数组R[low]到R[high]的调整，使R[low..high]成为一个大顶堆
void Sift(int R[], int low, int high) {
  int i = low, j = 2 * i;
  int temp = R[i];
  while (j <= high) {
    if (j < high && R[j] < R[j + 1]) // 如果右孩子较大，则把j指向右孩子
      ++j;
    if (temp < R[j]) { // 比较双亲和右孩子的大小
      R[i] = R[j];     // 将右孩子上移
      i = j;           // 修改i和j的值，以便继续向下筛选
      j = 2 * i;
    } else
      break; // 调整结束
  }
  R[i] = temp; // 被筛选结点的值放入最终位置
}

// 堆排序函数
void heapSort(int R[], int n) {
  int i;
  int temp;
  for (i = n / 2; i >= 1; i--)
    Sift(R, i, n);           // 建立初始堆
  for (i = n; i >= 2; i--) { // 进行n-1次循环，完成堆排序
    // 换出根节点中关键字，将其放入最终位置
    temp = R[1];
    R[1] = R[i];
    R[i] = temp;
    Sift(R, 1, i - 1); // 在减少了1个关键字的无序序列中进行调整，使其成为堆
  }
}
// 时间复杂度分析：
// 对于函数Sift()，现在j走了一条从当前节点到叶子结点的路径，完全二叉树高度为log2(n+1)，因此，Sift()的时间复杂度为O(log2n)。
// 对于函数heapsort()，基本操作总次数应该是两个并列的for循环中的基本操作次数之和，第一个循环的基本操作次数为n/2，第二个循环的基本操作次数为n-1，
// 因此，heapsort()的时间复杂度为O(nlog2n)。

// 二路归并排序
// 归并排序是一种树形选择排序，它的基本思想是：先将待排序的序列看成是n个长度为1的有序序列，然后进行两两归并，得到n/2个长度为2的有序序列，
// 再对长度为2的有序序列进行两两归并，得到n/4个长度为4的有序序列，如此反复进行下去，最后得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。
void merge(int A[], int low, int mid, int high) {
  int i = low, j = mid + 1;
  int k = 0;
  int *B = (int *)malloc((high - low + 1) * sizeof(int));
  // 比较两个大小，将较小的放入B中
  while (i <= mid && j <= high) {
    if (A[i] <= A[j])
      B[k++] = A[i++];
    else
      B[k++] = A[j++];
  }
  // 如果后半有剩下的，将后半剩下的放入B中
  if (j <= high) {
    for (; j <= high; j++)
      B[k++] = A[j];
  }
  // 如果前半有剩下的，将前半剩下的放入B中
  if (i <= mid) {
    for (; i <= mid; i++)
      B[k++] = A[i];
  }
  // 最后将B写回A中
  for (i = low, k = 0; i <= high; i++, k++)
    A[i] = B[k];
}

void mergeSort(int A[], int low, int high) {
  if (low < high) {
    int mid = (low + high) / 2;
    mergeSort(A, low, mid);      // 归并前半段
    mergeSort(A, mid + 1, high); // 归并后半点
    merge(A, low, mid, high); // 将low到mid和mid+1到high归并成一个有序序列
  }
}
// 时间复杂度分析：
// 归并排序中可选取函数merge()内的归并操作作为基本操作。函数merge的作用是将两个有序序列归并成一个整体有序的序列。
// 归并操作即为带归并表中的关键字复制到另一个存储归并结果的表中的过程。在顺序表中，函数merge()的归并操作执行次数为幺归并的
// 两个字序列中关键字个数之和。
// 整个归并排序的的时间复杂度为O(nlog2n)。即平均情况下、最好情况下和最坏情况下的时间复杂度均为O(nlog2n)。
// 空间复杂度分析：
// 因归并排序需要转存整个待排序列，因此空间复杂度为O(n)。
